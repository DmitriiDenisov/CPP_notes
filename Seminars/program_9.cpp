//По задаче,данная программа использует данные из программы 1.C
// Программа определяет идекс элемента,который наиболее близок по значению к среднему арифметическому
//массива,полученного в программе 1.C(без учета нулей).Программа выводит на экран 8-ми разрядное 
//двоичное представление числа(учитывая восьмиразрядность, автор выбрал случайное заполнение массива целыми числами
//из отрезка [1..255].В программе реализована одна пользовательская функция, возвращающая адрес найденного элемента.//
//Как результат работы программы, в консольное окно выводится среднее значение элементов массива(4 знака после запятой)//
//Индекс элемента(наименее отличающегося от ср.арифм),через несколько пробелов его значение,а также двоичное представление этого числа//
// Среда разработки: Microsoft Visual C++ 2012 Express			//
// Версия программы: 2.01  |  Автор: Денисов Д.М.,ПМИ,172			//
// Дата последнего изменения: 15.12.2013 	

#include "stdafx.h"
#include <iostream>
#include <ctime>
#include <iomanip>
#include <cstdlib>
#include <string>
using namespace std;

void ydalenie(int *arr,const int n)//пользовательская функция,удаляющая ненужные элементы.
{
	int num = 0;//переменная отвечающая за количество удаленных чисел
	int i = 0;
	bool flag;//булева переменная,фиксирует,выполнялось ли условие оканчивания на 3 или 5

	while (i < n)//будем идти по каждому i-му элементу и проверять,оканчивается ли он на 3 или 5
	{
		flag = true;
		if ((arr[i] % 10 == 5)||(arr[i] % 10 == 3))//если оканчивается на 3 или 5
		{
			flag = false;//переменная фиксирует заход в цикл for=>мы поймем, что это число было удалено
			for (int j = i ; j < n - 1 ; j++)
				arr[j] = arr[j + 1];//сдвиг влево
		}
		if (flag == false)//если захода не было(flag == true),то рассматриваем следующее число,то есть увеличиваем i на 1	
		{
			arr[n - 1 - num] = 0;//зануляем "освободившуюся" в следствие сдвига ячейку
			num++;//+1 к колчесву удаленных элементов :)
		}
		else
			i++;//Важный переход:если число удалилось=>сдигаем влево и число,которое мы ещё не рассматривали
		//теперь стоит на этом же место=>i не меняем. В случае же,если число не удалили=>i увеличиваем на 1
		//то есть рассматриваем уже следующее число
	}
}


int* number(int *arr,const int n,double b)//функция,ищущая номер элемента,наименее отличающегося от средн.арифм
{
	int i=0;//делаем по аналогии с задачей 1.B
	int min_num=0;
	double min=abs(b-arr[0]);
	while (arr[i]!=0)
	{
		if (abs(arr[i]-b)<min)
		{
			min=abs(arr[i]-b);
			min_num=i;
		}
		i++;
	}
	return (&min_num);//возвращаем номер
}


int _tmain(int argc, _TCHAR* argv[])
{
	const int N = 10;//размерность массива
	int arr[N];//массив
	string bin_value="";//с помощью этого массива переведем в двоичную сист.

	setlocale(LC_ALL, "Rus");
	srand(time(NULL));

	for (int i = 0 ; i < N ; i++)//случайное заполнение массива
		arr[i]=rand() % 255 + 1;

	//cout<<"Generated numbers:";//для удобства можете включить вывод сгенерированных элементов,чтобы убедиться в верности вычислений

	//for (int i = 0 ; i < N ; i++)
		//cout<<i<<"-th number: "<<arr[i]<<endl;

	ydalenie(arr,N);//вызываем функцию,обрабатывающую наш массив(удаляет все элементы,оканчив.на 3 или 5)

	double sum=0;//ищем сумму ненул.эл.
	int i=0;

	while ((i < N)&&(arr[i]!=0))//критерий остановки-когда наткнемся на нули(которые образовались в рез-те обработки массива функцией
								//или,если не было чисел,оканч.на 3 или 5,до последнего элемента
	{
		sum=sum+arr[i];//суммируем
		i++;
	}

	double srednee = sum / i;//среднее арифм.
	int c=*number(arr , N , srednee);//вызываем функцию,которая находит номер минимально отдаленного от ср.арифм.
	cout<<"среднее значение элементов массива= "<<fixed<<setprecision(4)<<srednee<<endl;//4 знака после запятой
	cout<<"индекс элемента="<<c<<setw(5)<<" Его значение="<<arr[c]<<endl;//выводим именно с,а не с+1 так как в задаче сказано,вывести индекс
	cout<<"Двоичное представление числа:";

	int remain;//вспомогательная переменная для перевода в двоич.сист

	while (arr[c])//цикл перевода в двоичную систему
	{
		remain=arr[c] % 2;
		arr[c] = arr[c] / 2;
		bin_value=(char)(remain+'0') + bin_value;//записываем в переменную типа стринг
	}
		cout<<bin_value;

	return 0;
}

