// ------------------------------------------------------------	//
// Программа случайным образом заполняет массив из 30-ти элементов целочисленными,
//неповторяющимися значениями в диапозоне [19;91].В программе присутствует одна пользовательская
//функция,заполняющая массив различными значениями и возвращающая общее число сгенерированных значений,которые потребовались для заполнения
//	массива значениями.Вывод полученных значений и количество сгенерированных чисел выводится в функции main в три строчки
//по 10 элементов.Также выводимые значения аккуратно выравниваются//
// Среда разработки: Microsoft Visual C++ 2012 Express			//
// Версия программы: 1.2  |  Автор: Денисов Д.М.,ПМИ,172			//
// Дата последнего изменения: 15.12.2013 						//
// ------------------------------------------------------------	//

#include "stdafx.h"
#include <cstdlib>
#include <iostream>
#include <ctime>
#include <iomanip>
using namespace std;

int zapolnenie(int *arr,const int n,const int left,const int right)
{
	bool flag;//переменная, которая "показывает",было ли сгенерированное число уникальным
	int i = 0;
	int num = 0;//количество сгенерированных чисел

	while (i < n)
	{
		flag = true;
		int b = rand() % (right - left) + left;
		num++;//счетчик количества сгенерированных чисел увеличиваем на 1

		for (int j = 0 ; j < n ; j++)
			if (b == arr[j])
				flag = false;//если число уже есть в массиве=> flag будет содержать значение false

		if (flag == true)//если же такое число уникальное=>запишем его и перейдем к следующей ячейке
		{
			arr[i] = b;
			i++;
		}
	}
	return num;
}


int _tmain(int argc, _TCHAR* argv[])
{
	const int left = 19;//левая граница заданного диапозона
	const int right = 91;//правая граница заданного диапозона
	const int N = 30;//количество элементов в массиве
	int arr[N];

	setlocale(LC_ALL, "Rus");
	srand(time(NULL));

	for (int i = 0 ; i < N ; i++)//заполняем массив числом -1,чтобы при проверке сгенерированного числа оно
		//заведомо не совпало ни с одним элементом(изначально там лежали "мусорные" значения,
			//поэтому приравниваем все элементы к числу,которое заведомо не будет сгенерировано		
				arr[i] = -1;

	int num = zapolnenie(arr , N , left , right);//переменная num-количество сгенерированных значений(возращает функция)

	int i = 0;

	for (int j = 1 ; j <= 3 ; j++)//отвечает за вывод слова трёх частей
	{
		int c = i;//запоминаем номер i
		cout<<"-элементы(Часть#"<<j<<")";
		while (i <= c + 9){
			cout<<setw(4)<<arr[i];//выравниваем
			i++;
		}
		cout<<endl;
	}
	cout<<"Число сгенерированных значений="<<num<<endl;

	return 0;
}

